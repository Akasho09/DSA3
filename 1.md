## 
class Solution {
public:
    vector<vector<int>> findDifference(vector<int>& nums1, vector<int>& nums2) {
        unordered_set<int>s1(nums1.begin(),nums1.end());
        unordered_set<int>s2(nums2.begin(),nums2.end());
        vector<int>l1,l2;
        for(int num : s1){
            if(s2.find(num)==s2.end()) l1.push_back(num);
        }
        for(int num : s2){
            if(s1.find(num)==s1.end()) l2.push_back(num);
        }
        return {move(l1),move(l2)};
    }
};

Avoid unnecessary copies
### Returning { move(diff1), move(diff2) } avoids copying vectors (uses move semantics).

Use .find() instead of .count()
Both are O(1), but .find() is slightly faster since it avoids an implicit comparison to 0/1.

Reserve capacity
diff1.reserve(s1.size()) and diff2.reserve(s2.size()) reduce dynamic reallocations.

No redundant temporary containers
Everything is done directly with the sets.


## 

class Solution {
public:
    void helper(int l , int h ,vector<int>& target , int & ans , int d , vector<vector<int>>&dp){
        if(l>=h) return 0; // 
        int low = target[l];
        for(int j=l+1;j<h;j++){
            if(target[j]<low) low = target[j];
        }
        return low-d;
        d=low;
        return dp[l][h] = helper(l,low,target,ans,d) + helper(low+1,h,target,ans,d);
    }
    int minNumberOperations(vector<int>& target) {
        int n = target.size(),i=0,ans=0;
        vector<vector<int>>dp(n+1,vector<int>(n+1,-1));
        helper(0,n,target,ans,0,dp);
        return ans;
    }
};  